---
slug: haskell-course-lesson-2
title: Haskell Course - Lesson 2 - Haskell Type system
date: 2022-03-10
author: robertinom
thumbnail: /images/meme-use-the-power-of-the-type-system.jpg
description: 'The second lesson of the "Haskell for complete beginners" course. The Haskell Type system.'
tags:
    - haskell-course
    - haskell
    - programming
---

Types are **attributes that constraint the values a piece of code can have**. For example, if you indicate that some data is a number, that data could have any of these values:

-   4
-   32
-   9999695939294
-   0.5

But, if you try to add a character in there, like this: `6A3` (instead of `63`), the compiler/<SideNote content={<p>What? You still don't know what an interpreter is? This was last week's homework! ü§£ It's ok, I don't like homework either. Here you go: <a href='https://en.wikipedia.org/wiki/Interpreter_(computing)' target='_blank'>Interpreter.</a></p>}>interpreter</SideNote> will yell at you: "That's not a number, you imbecile!" (you got a sassy one, my condolences).

What your compiler/interpreter did just there is called "**type checking**." Some languages have more strongly enforced type checking, some less.

First, we'll see an overview of the concepts, and then, we'll talk specifically about Haskell.

## Type checking

<p>
	<mark>
		Type checking is the process of verifying and enforcing the constraints
		of types.
	</mark>
</p>

**What does this mean?** It means that each type has its own constraints (E.g., you can't do math with letters. Unless... ü§î No, no, you can't), and this process checks that those constraints are respected.

<p>
	<b>Why would you do this?</b> To avoid preventable mistakes. If further
	along in your program, you want to add up some numbers and one of them has a
	letter, the program wouldn't know what to do, and it would{' '}
	<SideNote
		content={
			<div>
				<h4>Crash (programming)</h4>
				<p>
					A <b>crash</b>, or <b>system crash</b>, occurs when a
					program such as a software application or an operating
					system stops functioning properly and exits (stops
					executing/running).
				</p>
			</div>
		}
	>
		crash
	</SideNote>{' '}
	on you. Those are preventable mistakes{' '}
	<SideNote
		content={
			<div>
				<h4>Bugs (programming)</h4>
				<p>
					Bugs are the result of a mistake in the code. They are
					errors that produce an incorrect, unexpected, or unintended
					result or behaviour in the program.
				</p>
				<p>
					{' '}
					Once encountered, those bugs have to be resolved.
					<b>Debugging</b> is the process of finding and fixing bugs
				</p>
			</div>
		}
	>
		(bugs)
	</SideNote>
	, and the compiler/interpreter helps you avoid them.
</p>

Usually, this is done automatically. But not all languages do this the same way. There are two main distinctions regarding as to **WHEN** the types are checked.

### Dynamically typed languages

**Dynamically typed languages check the types at run-time**. Run-time is the very last thing that you do with a program. It's the stage when you run your program to test it or use it.

Meaning that **you won't know if your types are correct until you actually use the program**. And if your types are wrong, your program will crash.

Common examples of dynamically-typed languages include JavaScript, Python, Objective-C, and PHP.

The counterpart of dynamically typed languages are **statically typed** languages.

### Statically typed languages

**Statically typed languages check the types at compile-time**. Meaning that you'll know if your types are wrong as soon as you compile your program (and some IDEs will show you the exact place where the error occurs). Which leads to a safer and more optimized code.

Common examples of statically-typed languages include Java, C, and C++.

It sounds like all programming languages should be statically typed, but it's not that simple. **Both statically and dynamically typed languages have their pros and cons.** In some cases, you want to use dynamically typed languages (E.g., quick prototyping), and in others, you want to use statically typed languages (E.g., writing robust and optimized programs).

That's our overview of the general concepts. Now let's see how Haskell fits into all of this.

## Haskell type system

<p>
	<mark>Haskell is statically typed</mark>. And, in Haskell,{' '}
	<b>Everything has a type</b>.
</p>

<Giff url='https://giphy.com/embed/AO3giAtLPH4MIuugsB' />

And not only that. In some programming languages, each time you write a piece of code, you have to indicate the types. But not in Haskell! Haskell is smarter than other languages ü§ì because it has **type inference**.

**Type inference allows Haskell to infer the types on its own**. If you write something like `3 + 4`, Haskell will know that the result of that expression is a number, and it will treat like it without the need for you to specify anything.

**That allows the compiler to comprehend and reason _quite a lot_ about your program**. Providing you with a pretty effective bug-catching assistant. üí™
(You still have to write sensible code though, you can't expect the compiler to do all the work. üòú)

<Giff url='https://giphy.com/embed/3o7ZesJdQccI0sO3fy' />

But what if the code is ambiguous or can have more than one type? (we'll see examples in future lessons). Haskell will try to infer the type, and if it can't, it will ‚Äî you guessed it ‚Äî **yell at you** to specify it. üòÇ

But how do you know/set the type? To see and specify the type of a piece of code, we use the `::` operator.

## The :: operator

An operator is a **symbol to perform specific mathematical, relational, or logical operations**. In this case, the `::` operator is used to **show or assign types.**

When you read code with that operator, you can read it as "has type of."
Here's how it looks:

```hs
üê¨ :: Animal -- This reads as: üê¨ has type of Animal

ü•ê :: Food   -- This reads as: ü•ê has type of Food
```

Obviously, those are not standard Haskell types. We'll explore the properties of the most common Haskell types and the use of the `::` operator in practice in the following lectures.

And that's it for today! üôÉ Make sure to do the homework and solidify today's concepts! ü§ì

## Homework

1. Answer these questions in your head and open them to check your answer (repeat every few minutes until you get all of them right):

<Accordion
	title='What are types?'
	content={
		<p>Attributes that constraint the values a piece of code can have</p>
	}
/>
<Accordion
	title='What is type checking?'
	content={
		<p>The process of verifying and enforcing the constraints of types.</p>
	}
/>
<Accordion
	title="What's the difference between dynamically and statically typed languages?"
	content={
		<p>
			Dynamically typed languages check the types at run-time, and
			statically typed languages, check the types at compile-time.
		</p>
	}
/>
<Accordion
	title="What happens if I don't indicate the type in Haskell?"
	content={
		<p>
			Haskell will try to infer the type. And if it can't, it'll ask me to
			specify it.
		</p>
	}
/>
<Accordion
	title='How do you express "USD has type of Currency" in Haskell?'
	content={
		<pre>
			<code className='hljs language-hs'>
				USD :: <span className='hljs-type'>Currency</span>{' '}
			</code>
		</pre>
	}
/>

2. Search the difference between **strongly typed languages** and **weakly typed languages**.

In the next lesson, we'll learn about Numbers in Haskell! ‚ûï‚ûñ‚ûó‚úñÔ∏è See you there!! üòÑ

<p
	style={{
		backgroundColor: '#dbd6fb',
		padding: '0.5rem 1rem',
		borderRadius: '4px',
		color: '#733de4',
	}}
>
	<i>
		PD: If you find this course valuable, please{' '}
		<a
			href='https://twitter.com/share?url=https://robertinom.com/posts/haskell-course-lesson-0'
			target='_blank'
		>
			share it
		</a>{' '}
		so more people can learn!
	</i>{' '}
	üòÑ
</p>

<LessonNavigationButtons nextLesson='haskell-course-lesson-3' />
